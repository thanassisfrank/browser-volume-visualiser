# fun3d_data.py

# Reader for the NASA retro propulsion volume data generated by FUN3D
# > https://data.nas.nasa.gov/fun3d


import numpy as np

class File ():
    __file = None
    __file_bytes = None
    __header = {}
    __bytes_per_t_step = 0
    __t_step_count = 0

    def __init__(self, path):
        self.__file = open(path, "rb")
        self.__file_bytes = np.frombuffer(self.__file.read(), dtype=np.uint8)
        self.__extract_header()

        # test for the magic number
        if self.__header["magic"] != 305419896:
            self.close()
        
        self.__bytes_per_t_step = (self.__header["n_nodes"] * self.__header["n_variables"] + 1) * 4

        self.__t_step_count = len(self.__file_bytes)//self.__bytes_per_t_step

    def __extract_header(self):
        # current byte position
        curr_ptr = 0

        def read_int():
            nonlocal curr_ptr
            val = self.__file_bytes[curr_ptr : curr_ptr + 4].view(np.uint32)[0]
            curr_ptr += 4
            return val

        # strings are encoded in ascii (8 bit chars) with their length prepended
        def read_string():
            nonlocal curr_ptr
            char_length = read_int()
            charcodes = self.__file_bytes[curr_ptr : curr_ptr + char_length]
            curr_ptr += char_length
            return "".join(map(chr, charcodes))
        
        def read_uint64_arr(elems):
            nonlocal curr_ptr
            arr = self.__file_bytes[curr_ptr : curr_ptr + elems * 8].view(np.uint64)
            curr_ptr += elems * 8
            return arr

        self.__header = {
            "magic": read_int(),
            "version": read_string(),
            "n_nodes_0": read_int(),
            "n_nodes": read_int(),
            "n_variables": read_int(),
        }

        self.__header["variables"] = [read_string() for i in range(self.__header["n_variables"])]

        self.__header["local_to_global"] = read_uint64_arr(self.__header["n_nodes"])

        # how long the header is in bytes
        self.__header["bytes"] = curr_ptr

    def get_variable_names(self):
        return self.__header["variables"]
    
    def get_value_array(self, name, t_index = 0):
        if t_index >= self.__t_step_count:
            # past the maximum time step
            return None
        
        try:
            var_index = self.__header["variables"].index(name)
        except ValueError:
            # no matching variable
            return None
        
        # read data
        file_data_bytes = self.__file_bytes[self.__header["bytes"]:]
        
        # get the 
        # t_step_num = file_data_bytes[self.__bytes_per_t_step * t_index : self.__bytes_per_t_step * t_index + 4].view(np.uint32)[0]

        t_step_reals = file_data_bytes[self.__bytes_per_t_step * t_index + 4 : self.__bytes_per_t_step * (t_index + 1)].view(np.float32)

        return t_step_reals[var_index::self.__header["n_variables"]]

    def close(self):
        self.__file.close()
