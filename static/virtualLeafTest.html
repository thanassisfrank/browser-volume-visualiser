<!DOCTYPE html>
<html>
    <head>
        <title>virtual leaf test</title>
        <style>
            body {margin: 0px; padding: 20px}
            #c {width: 700px; height: 700px}
        </style>
    </head>
    <body>
        <canvas id="c"></canvas>
        <p id="time">0ms</p>
        <script type="module">
            import { get, setupCanvasDims } from "./core/utils.js";
            import { VecMath } from "./core/VecMath.js";
            const epsilon = 0.01;
            
            var canvas = get("c");
            setupCanvasDims(canvas);
            var max = [canvas.width, canvas.height];
            var ctx = canvas.getContext("2d");

            // scalar data functions ===================================================================
            
            const perlinVerts = ((n) => {
                var out = [];
                for (let i = 0; i < n; i++) {
                    out[i] = [];
                    for (let j = 0; j < n; j++) {
                        out[i][j] = [Math.random() * 2 * Math.PI, Math.random() * 2 * Math.PI];
                    }
                }
                return out;
            })(8);

            const smoothStep = (x) =>  6*x**5 - 15*x**4 + 10*x**3;

            const lerp = (a, b, x) => {
                return a * (1-x) + b * x;
            }

            const samplePerlin = (x, y) => {
                const xIndex = x/canvas.width * (perlinVerts[0].length-1);
                const yIndex = y/canvas.height * (perlinVerts.length-1);
                const xProp = xIndex - Math.floor(xIndex);
                const yProp = yIndex - Math.floor(yIndex);


                const cornerGrads = [
                    [perlinVerts[Math.floor(yIndex)][Math.floor(xIndex)], perlinVerts[Math.floor(yIndex)][Math.ceil(xIndex)]],
                    [perlinVerts[Math.ceil(yIndex)][Math.floor(xIndex)], perlinVerts[Math.ceil(yIndex)][Math.ceil(xIndex)]]
                ];

                const dotProds = [
                    [VecMath.dot(cornerGrads[0][0], [xProp, yProp]), VecMath.dot(cornerGrads[0][1], [xProp - 1, yProp])],
                    [VecMath.dot(cornerGrads[1][0], [xProp, yProp - 1]), VecMath.dot(cornerGrads[1][1], [xProp - 1, yProp - 1])],
                ]

                var val = lerp(
                    lerp(dotProds[0][0], dotProds[0][1], smoothStep(xProp)),
                    lerp(dotProds[1][0], dotProds[1][1], smoothStep(xProp)),
                    smoothStep(yProp)
                );

                // (dotProds[0][0] * (1-xProp) * (1-yProp) + 
                //        dotProds[0][1] * xProp * (1-yProp) + 
                //        dotProds[1][0] * (1-xProp) * yProp + 
                //        dotProds[1][1] * xProp * yProp);
                
                return (val + 1)/2;
            }

            const sampleWave = (x, y) => {
                return 0.5 + 0.5 * Math.cos(Math.sqrt(x**2 + y**2)/20);
            }


            const scalarFunction = sampleWave;


            // Drawing ================================================================================
                
            const drawScalarField = (f) => {
                var imgData = new Uint8ClampedArray(4 * canvas.height * canvas.width);
                for (let i = 0; i < canvas.width; i++) {
                    for (let j = 0; j < canvas.height; j++) {
                        const index = 4 * (i + j * canvas.width);
                        const val = f(i, j);
                        imgData[index + 0] = val * 255;
                        imgData[index + 1] = val * 255;
                        imgData[index + 2] = val * 255;
                        imgData[index + 3] = 255;
                    }
                }
                var newImg = new ImageData(imgData, canvas.width, canvas.height);
                ctx.putImageData(newImg, 0, 0);
            }

            const drawTree = (tree, col) => {
                var nodeQueue = [tree];
                while(nodeQueue.length > 0) {
                    var currNode = nodeQueue.pop();
                    if (!currNode.left) {
                        drawBox(currNode.box, col);
                    } else {
                        nodeQueue.push(currNode.left, currNode.right);
                    }
                }
            };
            
            const drawBox = (box, col) => {
                ctx.strokeStyle = col;
                ctx.strokeRect(
                    box.min[0],
                    box.min[1],
                    box.max[0] - box.min[0],
                    box.max[1] - box.min[1]
                );
            }

            const drawTreeCornerVals= (tree, mode) => {
                var imgData = new Uint8ClampedArray(4 * canvas.height * canvas.width);
                for (let i = 0; i < canvas.width; i++) {
                    for (let j = 0; j < canvas.height; j++) {
                        const index = 4 * (i + j * canvas.width);
                        var val;
                        if (mode == "virtualOld") {
                            const leaf = getVirtualLeafOld(tree, [i, j]);
                            val = sampleInBox(leaf.node.box, leaf.cornerVals, [i, j]);
                        } else if (mode == "virtual") {
                            val = sampleTreeVirtual(tree, [i, j]);
                        } else if ("median" == mode) {
                            val = sampleTreeVirtualNodeMedian(tree, [i, j]);
                        } else if ("nearest" == mode) {
                            const leaf = getContainingLeafNode(tree, [i, j]);
                            val = sampleInBoxNearest(leaf.node.box, leaf.cornerVals, [i, j]);
                        } else{
                            const leaf = getContainingLeafNode(tree, [i, j]);
                            val = sampleInBox(leaf.node.box, leaf.cornerVals, [i, j]);
                        }
                        imgData[index + 0] = val * 255;
                        imgData[index + 1] = val * 255;
                        imgData[index + 2] = val * 255;
                        imgData[index + 3] = 255;
                    }
                }
                var newImg = new ImageData(imgData, canvas.width, canvas.height);
                ctx.putImageData(newImg, 0, 0);
            };
   
            
            // tree creation/searching ======================================
            
            const createTree = (d, box, f) => {
                var out = {
                    nodes: null,
                    cornerVals: []
                };
                // (xmin, ymin), (xmax, ymin), (xmin, ymax), (xmax, ymax)
                const writeNodeCornerVals = (node) => {
                    // console.log(node.index);
                    out.cornerVals[4 * node.index + 0] = f(node.box.min[0], node.box.min[1]);
                    out.cornerVals[4 * node.index + 1] = f(node.box.max[0], node.box.min[1]);
                    out.cornerVals[4 * node.index + 2] = f(node.box.min[0], node.box.max[1]);
                    out.cornerVals[4 * node.index + 3] = f(node.box.max[0], node.box.max[1]);
                }
                
                var nodeIndex = 0;
                // generate the tree and corner values together
                var root = {
                    depth: 0,
                    splitDimension: 0,
                    splitVal: null,
                    left: null,
                    right: null,
                    index: 0, // for where to write the corner values to
                    box: structuredClone(box)
                };

                writeNodeCornerVals(root);

                out.nodes = root;

                var nodeQueue = [root];

                

                while (nodeQueue.length > 0) {
                    var currNode = nodeQueue.pop();
                    // check if max depth has been reached
                    if (currNode.depth > d) continue;
                    // randomly chosen not to split
                    if (Math.random() < 0.2 && currNode.depth > d/2) continue;

                    // chose split val
                    // const range = currNode.box.max[currNode.splitDimension] - currNode.box.min[currNode.splitDimension];
                    // const mid = 0.5 * (currNode.box.max[currNode.splitDimension] + currNode.box.min[currNode.splitDimension]);
                    // currNode.splitVal = mid + (Math.random() - 0.5) * range * 0.3;

                    currNode.splitVal = 0.5 * (currNode.box.max[currNode.splitDimension] + currNode.box.min[currNode.splitDimension]);

                    currNode.left = {
                        depth: currNode.depth + 1,
                        splitDimension: (currNode.splitDimension + 1) % 2,
                        splitVal: null,
                        left: null,
                        right: null,
                        index: ++nodeIndex, // for where to write the corner values to
                        box: structuredClone(currNode.box)
                    };

                    currNode.left.box.max[currNode.splitDimension] = currNode.splitVal;

                    currNode.right = {
                        depth: currNode.depth + 1,
                        splitDimension: (currNode.splitDimension + 1) % 2,
                        splitVal: null,
                        left: null,
                        right: null,
                        index: ++nodeIndex, // for where to write the corner values to
                        box: structuredClone(currNode.box)
                    };

                    currNode.right.box.min[currNode.splitDimension] = currNode.splitVal;

                    writeNodeCornerVals(currNode.left);
                    writeNodeCornerVals(currNode.right);

                    nodeQueue.push(currNode.left, currNode.right)
                }

                console.log("number of nodes:", nodeIndex + 1);

                return out;
            };
            
            const sampleInBox = (box, cornerVals, p) => {
                var xFac = Math.min(1, Math.max(0, (p[0] - box.min[0])/(box.max[0] - box.min[0])));
                var yFac = Math.min(1, Math.max(0, (p[1] - box.min[1])/(box.max[1] - box.min[1])));
                return lerp(
                    lerp(cornerVals[0], cornerVals[1], xFac),
                    lerp(cornerVals[2], cornerVals[3], xFac),
                    yFac
                );
            }
            
            const sampleInBoxNearest = (box, cornerVals, p) => {
                var xFac = Math.round((p[0] - box.min[0])/(box.max[0] - box.min[0]));
                var yFac = Math.round((p[1] - box.min[1])/(box.max[1] - box.min[1]));
                return lerp(
                    lerp(cornerVals[0], cornerVals[1], xFac),
                    lerp(cornerVals[2], cornerVals[3], xFac),
                    yFac
                );
            }
            
            const getContainingLeafNode = (tree, p) => {
                var currNode = tree.nodes;
                
                while (currNode.left) {
                    currNode = p[currNode.splitDimension] < currNode.splitVal ? currNode.left : currNode.right;
                }

                return {
                    node: currNode,
                    cornerVals: tree.cornerVals.slice(4*currNode.index, 4*currNode.index + 4)
                };
            };
            
            const facInRange = (x, min, max) => {
                return (x - min)/(max - min);
            }
            
            // (xmin, ymin), (xmax, ymin), (xmin, ymax), (xmax, ymax)
            // +--->x
            // |   0  |   |  1
            // V    +-------+
            // y -- |       | -- min
            //      |       |
            //   -- |       | -- max
            //      +-------+ 
            //     2  |   |  3
            //       min max
            
            // extract the virtual leaf that the point is inside of and estimate its corner values
            const getVirtualLeafOld = (tree, p) => {
                // traverse the tree to get the containing leaf node
                var fullLeaf = getContainingLeafNode(tree, p);
                var virtBox = {
                    min: [...fullLeaf.node.box.min],
                    max: [...fullLeaf.node.box.max],
                };
                var virtCorn = fullLeaf.cornerVals.slice();

                const points = [
                    [p[0], fullLeaf.node.box.max[1] + epsilon], // y+
                    [fullLeaf.node.box.max[0] + epsilon, p[1]], // x+
                    [p[0], fullLeaf.node.box.min[1] - epsilon], // y-
                    [fullLeaf.node.box.min[0] - epsilon, p[1]]  // x-
                ];

                // one entry for each projection point
                const corners = [
                    {
                        min: {
                            new: 0,
                            adj: {
                                dst: 2,
                                curr: [2, 3]
                            },
                            opp: {
                                dst: 0,
                                curr: [0, 1]
                            }
                        },
                        max: {
                            new: 1,
                            adj: {
                                dst: 3,
                                curr: [2, 3]
                            },
                            opp: {
                                dst: 1,
                                curr: [0, 1]
                            }
                        }
                    },
                    {
                        min: {
                            new: 0,
                            adj: {
                                dst: 1,
                                curr: [1, 3]
                            },
                            opp: {
                                dst: 0,
                                curr: [0, 2]
                            }
                        },
                        max: {
                            new: 2,
                            adj: {
                                dst: 3,
                                curr: [1, 3]
                            },
                            opp: {
                                dst: 2,
                                curr: [0, 2]
                            }
                        }
                    },
                    {
                        min: {
                            new: 2,
                            adj: {
                                dst: 0,
                                curr: [0, 1]
                            },
                            opp: {
                                dst: 2,
                                curr: [2, 3]
                            }
                        },
                        max: {
                            new: 3,
                            adj: {
                                dst: 1,
                                curr: [0, 1]
                            },
                            opp: {
                                dst: 3,
                                curr: [2, 3]
                            }
                        }
                    },
                    {
                        min: {
                            new: 1,
                            adj: {
                                dst: 0,
                                curr: [0, 2]
                            },
                            opp: {
                                dst: 1,
                                curr: [1, 3]
                            }
                        },
                        max: {
                            new: 3,
                            adj: {
                                dst: 2,
                                curr: [0, 2]
                            },
                            opp: {
                                dst: 3,
                                curr: [1, 3]
                            }
                        }
                    }
                ];


                // new version with LUT
                for (let i = 0; i < 4; i++) {
                    const newLeaf = getContainingLeafNode(tree, points[i]);
                    const dim = i%2;
                    const otherDim = (i+1)%2;

                    // console.log(virtCorn);

                    // change the new factor based on whether this point is on the + or - face
                    var adjNewFac, oppNewFac;
                    if (i < 2) {
                        // + face
                        adjNewFac = facInRange(virtBox.max[otherDim], fullLeaf.node.box.min[otherDim], fullLeaf.node.box.max[otherDim]);
                        oppNewFac = facInRange(virtBox.min[otherDim], fullLeaf.node.box.min[otherDim], fullLeaf.node.box.max[otherDim]);
                    } else {
                        adjNewFac = facInRange(virtBox.min[otherDim], fullLeaf.node.box.min[otherDim], fullLeaf.node.box.max[otherDim]);
                        oppNewFac = facInRange(virtBox.max[otherDim], fullLeaf.node.box.min[otherDim], fullLeaf.node.box.max[otherDim]);

                    }


                    if (newLeaf.node.box.min[dim] > virtBox.min[dim]) {
                        // adjacent
                        virtCorn[corners[i].min.adj.dst] = lerp(
                            lerp(
                                virtCorn[corners[i].min.adj.curr[0]], 
                                virtCorn[corners[i].min.adj.curr[1]], 
                                facInRange(newLeaf.node.box.min[dim], virtBox.min[dim], virtBox.max[dim]) // (1)
                            ),
                            newLeaf.cornerVals[corners[i].min.new],
                            adjNewFac      // (2)
                        );

                        // opposite
                        virtCorn[corners[i].min.opp.dst] = lerp(
                            lerp(
                                virtCorn[corners[i].min.opp.curr[0]], 
                                virtCorn[corners[i].min.opp.curr[1]], 
                                facInRange(newLeaf.node.box.min[dim], virtBox.min[dim], virtBox.max[dim]) // (1)
                            ),
                            newLeaf.cornerVals[corners[i].min.new],
                            oppNewFac   // (2)
                        );

                        // update box
                        virtBox.min[dim] = newLeaf.node.box.min[dim];
                    }

                    if (newLeaf.node.box.max[dim] < virtBox.max[dim]) {
                        // adjacent
                        virtCorn[corners[i].max.adj.dst] = lerp(
                            lerp(
                                virtCorn[corners[i].max.adj.curr[0]], 
                                virtCorn[corners[i].max.adj.curr[1]], 
                                facInRange(newLeaf.node.box.max[dim], virtBox.min[dim], virtBox.max[dim]) // (1)
                            ),
                            newLeaf.cornerVals[corners[i].max.new],
                            adjNewFac      // (2)
                        );

                        // opposite
                        virtCorn[corners[i].max.opp.dst] = lerp(
                            lerp(
                                virtCorn[corners[i].max.opp.curr[0]], 
                                virtCorn[corners[i].max.opp.curr[1]], 
                                facInRange(newLeaf.node.box.max[dim], virtBox.min[dim], virtBox.max[dim]) // (1)
                            ),
                            newLeaf.cornerVals[corners[i].max.new],
                            oppNewFac     // (2)
                        );

                        virtBox.max[dim] = newLeaf.node.box.max[dim];
                    }
                }





                // project the point to the four faces of the leaf and slightly beyond

                // // project in +y direction
                // var projP1 = [p[0], leaf.box.max[1] + epsilon];
                // var p1Leaf = getContainingLeafNode(tree, projP1).node;
                // //check if the box is smaller in x direction
                
                // // the new corner is the same is each of these if blocks
                // // (1) the same min/max value is used
                // // (2) the other dimension is used when entering and within block

                // if (p1Leaf.box.min[0] > virtBox.min[0]) {                                 // (1) (2)
                //     // adjacent: interp 2 val from curr 2, 3 and new 0
                //     virtCorn[2] = lerp(
                //         lerp(
                //             virtCorn[2], 
                //             virtCorn[3], 
                //             facInRange(p1Leaf.box.min[0], virtBox.min[0], virtBox.max[0]) // (1)
                //         ),
                //         p1Leaf.cornerVals[0],
                //         facInRange(virtBox.max[1], leaf.box.min[1], leaf.box.max[1])      // (2)
                //     );

                //     // opposite: interp 0 val from curr 0, 1 and new 0
                //     virtCorn[0] = lerp(
                //         lerp(
                //             virtCorn[0], 
                //             virtCorn[1], 
                //             facInRange(p1Leaf.box.min[0], virtBox.min[0], virtBox.max[0]) // (1)
                //         ),
                //         p1Leaf.cornerVals[0],
                //         facInRange(virtBox.min[1], leaf.box.min[1], leaf.box.max[1])      // (2)
                //     );
                //     // update box
                //     virtBox.min[0] = p1Leaf.box.min[0];
                // }

                // if (p1Leaf.box.max[0] < virtBox.max[0]) {
                //     // adjacent: interp 3 from curr 2, 3 and new 1
                //     virtCorn[3] = lerp(
                //         lerp(
                //             virtCorn[2], 
                //             virtCorn[3], 
                //             facInRange(p1Leaf.box.max[0], virtBox.min[0], virtBox.max[0])
                //         ),
                //         p1Leaf.cornerVals[1],
                //         facInRange(virtBox.max[1], leaf.box.min[1], leaf.box.max[1])
                //     );
                //     // opposite: interp 1 val from curr 0, 1 and new 1
                //     virtCorn[1] = lerp(
                //         lerp(
                //             virtCorn[0], 
                //             virtCorn[1], 
                //             facInRange(p1Leaf.box.max[0], virtBox.min[0], virtBox.max[0])
                //         ),
                //         p1Leaf.cornerVals[0],
                //         facInRange(virtBox.min[1], leaf.box.min[1], leaf.box.max[1])
                //     );
                //     // update box
                //     virtBox.max[0] = p1Leaf.box.max[0];
                // }



                // // project in +x direction
                // var projP2 = [leaf.box.max[0] + epsilon, p[1]];
                // var p2Leaf = getContainingLeafNode(tree, projP2).node;
                // //check if the box is smaller in y direction
                // if (p2Leaf.box.min[1] > virtBox.min[1]) {
                //     // adjacent: interp 3 from curr 1, 3 and new 0
                //     virtCorn[1] = lerp(
                //         lerp(
                //             virtCorn[1], 
                //             virtCorn[3], 
                //             facInRange(p2Leaf.box.min[0], virtBox.min[0], virtBox.max[0]) // (1)
                //         ),
                //         p1Leaf.cornerVals[0],
                //         facInRange(virtBox.max[1], leaf.box.min[1], leaf.box.max[1])      // (2)
                //     );

                //     virtBox.min[1] = p2Leaf.box.min[1];
                // }
                // if (p2Leaf.box.max[1] < virtBox.max[1]) {
                //     virtBox.max[1] = p2Leaf.box.max[1];
                // }

                // // project in -y direction
                // var projP3 = [p[0], leaf.box.min[1] - epsilon];
                // var p3Leaf = getContainingLeafNode(tree, projP3).node;
                // //check if the box is smaller in x direction
                // if (p3Leaf.box.min[0] > virtBox.min[0]) {
                //     virtBox.min[0] = p3Leaf.box.min[0];
                // }
                // if (p3Leaf.box.max[0] < virtBox.max[0]) {
                //     virtBox.max[0] = p3Leaf.box.max[0];
                // }

                // // project in -x direction
                // var projP4 = [leaf.box.min[0] - epsilon, p[1]];
                // var p4Leaf = getContainingLeafNode(tree, projP4).node;
                // //check if the box is smaller in y direction
                // if (p4Leaf.box.min[1] > virtBox.min[1]) {
                //     virtBox.min[1] = p4Leaf.box.min[1];
                // }
                // if (p4Leaf.box.max[1] < virtBox.max[1]) {
                //     virtBox.max[1] = p4Leaf.box.max[1];
                // }


                return {
                    node: {box: virtBox},
                    cornerVals: virtCorn
                };
            };
    
            
            // sample the tree using the intersecting perpendicular virtual leaf nodes
            const sampleTreeVirtual = (tree, p) => {
                
                const makeEdgePoints = (fullLeaf, fullCorners, neighbourLeaf, neighbourCorners, dim) => {
                    var points = {
                        val: [fullLeaf.cornerVals[fullCorners[0]]], 
                        pos: [fullLeaf.node.box.min[dim]]
                    };
                    if (neighbourLeaf.node.box.min[dim] > fullLeaf.node.box.min[dim]) {
                        points.val[1] = neighbourLeaf.cornerVals[neighbourCorners[0]];
                        points.pos[1] = neighbourLeaf.node.box.min[dim];
                    }
                    if (neighbourLeaf.node.box.max[dim] < fullLeaf.node.box.max[dim]) {
                        points.val.push(neighbourLeaf.cornerVals[neighbourCorners[1]]);
                        points.pos.push(neighbourLeaf.node.box.max[dim]);
                    }
                    points.val.push(fullLeaf.cornerVals[fullCorners[1]]);
                    points.pos.push(fullLeaf.node.box.max[dim]);

                    return points;
                }
                
                // function for interpolating a point along an edge with multiple points along it
                const lerpEdgePoints = (points, pos) => {
                    var val = 0;

                    for (let i = 0; i < points.val.length - 1; i++) {
                        if (pos >= points.pos[i] && pos <= points.pos[i + 1]) {
                            // is inside this range, lerp here
                            val = lerp(
                                points.val[i], 
                                points.val[i + 1], 
                                facInRange(pos, points.pos[i], points.pos[i + 1])
                            );
                            break;
                        }
                    }
                    // for (let i = 0; i < points.length - 1; i++) {
                    //     if (pos >= points[i].pos && pos <= points[i + 1].pos) {
                    //         // is inside this range, lerp here
                    //         val = lerp(
                    //             points[i].val, 
                    //             points[i + 1].val, 
                    //             facInRange(pos, points[i].pos, points[i + 1].pos)
                    //         );
                    //         break;
                    //     }
                    // }

                    return val;
                };
                
                const updateVirtCorners = (
                    fullLeaf, virtCorners, virtBox, 
                    plusNeighbourLeaf, plusPoints,
                    minusNeighbourLeaf, minusPoints,
                    minCorners, maxCorners, dim
                ) => {
                    if (virtBox.min[dim] > fullLeaf.node.box.min[dim]) {
                        if (virtBox.min[dim] == plusNeighbourLeaf.node.box.min[dim]) {
                            // is set by plus neighbour
                            // replace 1 with new 0
                            virtCorners[minCorners[0]] = plusNeighbourLeaf.cornerVals[minCorners[1]];
                            // interpolate new 0 along x- side
                            virtCorners[minCorners[1]] = lerpEdgePoints(minusPoints, virtBox.min[dim]);
                        } else {
                            // is set by x- neighbour
                            // replace 0 with new 1
                            virtCorners[minCorners[1]] = minusNeighbourLeaf.cornerVals[minCorners[0]];
                            // interpolate new 1
                            virtCorners[minCorners[0]] = lerpEdgePoints(plusPoints, virtBox.min[dim]);
                        }
                    }

                    if (virtBox.max[dim] < fullLeaf.node.box.max[dim]) {
                        if (virtBox.max[dim] == plusNeighbourLeaf.node.box.max[dim]) {
                            // set by x+ neighbour
                            virtCorners[maxCorners[0]] = plusNeighbourLeaf.cornerVals[maxCorners[1]];
                            // interpolate new 2 along x- side
                            virtCorners[maxCorners[1]] = lerpEdgePoints(minusPoints, virtBox.max[dim]);
                        } else {
                            // set by x- neighbour
                            virtCorners[maxCorners[1]] = minusNeighbourLeaf.cornerVals[maxCorners[0]];
                            virtCorners[maxCorners[0]] = lerpEdgePoints(plusPoints, virtBox.max[dim]);
                        }
                    }

                    return virtCorners;
                }
                
                var fullLeaf = getContainingLeafNode(tree, p);

                // do the x aligned virtual box first ==================================================================
                var xVirtBox = {
                    min: [...fullLeaf.node.box.min],
                    max: [...fullLeaf.node.box.max],
                };
                var xVirtCorn = fullLeaf.cornerVals.slice();

                // look at the neighbours on the + and - x sides
                var xPlusLeaf = getContainingLeafNode(tree, [fullLeaf.node.box.max[0] + epsilon, p[1]]);
                var xMinusLeaf = getContainingLeafNode(tree, [fullLeaf.node.box.min[0] - epsilon, p[1]]);

                // create the points arrays
                var xPlusPoints = makeEdgePoints(fullLeaf, [1, 3], xPlusLeaf, [0, 2], 1);
                var xMinusPoints = makeEdgePoints(fullLeaf, [0, 2], xMinusLeaf, [1, 3], 1);

                // form the virtual x box
                xVirtBox.min[1] = Math.max(
                    fullLeaf.node.box.min[1],
                    xPlusLeaf.node.box.min[1], 
                    xMinusLeaf.node.box.min[1]
                );

                xVirtBox.max[1] = Math.min(
                    fullLeaf.node.box.max[1],
                    xPlusLeaf.node.box.max[1], 
                    xMinusLeaf.node.box.max[1]
                );

                updateVirtCorners(fullLeaf, xVirtCorn, xVirtBox, xPlusLeaf, xPlusPoints, xMinusLeaf, xMinusPoints, [1, 0], [3, 2], 1);

                // interpolate within the virtual x box
                var xSampled = sampleInBox(xVirtBox, xVirtCorn, p);

                // y aligned box ======================================================================================
                var yVirtBox = {
                    min: [...fullLeaf.node.box.min],
                    max: [...fullLeaf.node.box.max],
                };
                var yVirtCorn = fullLeaf.cornerVals.slice();

                // look at the neighbours on the + and - x sides
                var yPlusLeaf = getContainingLeafNode(tree, [p[0], fullLeaf.node.box.max[1] + epsilon]);
                var yMinusLeaf = getContainingLeafNode(tree, [p[0], fullLeaf.node.box.min[1] - epsilon]);

                // create the points array for the x+ side of the box
                var yPlusPoints = makeEdgePoints(fullLeaf, [2, 3], yPlusLeaf, [0, 1], 0);
                var yMinusPoints = makeEdgePoints(fullLeaf, [0, 1], yMinusLeaf, [2, 3], 0);

                yVirtBox.min[0] = Math.max(
                    fullLeaf.node.box.min[0],
                    yPlusLeaf.node.box.min[0], 
                    yMinusLeaf.node.box.min[0]
                );

                yVirtBox.max[0] = Math.min(
                    fullLeaf.node.box.max[0],
                    yPlusLeaf.node.box.max[0], 
                    yMinusLeaf.node.box.max[0]
                );

                updateVirtCorners(fullLeaf, yVirtCorn, yVirtBox, yPlusLeaf, yPlusPoints, yMinusLeaf, yMinusPoints, [2, 0], [3, 1], 0);

                const ySampled = sampleInBox(yVirtBox, yVirtCorn, p);
                

                // combine the samples from the virtual leaves ===========================================================================

                const xFac = facInRange(p[0], fullLeaf.node.box.min[0], fullLeaf.node.box.max[0]);
                const xVirtFac = Math.max(xFac, 1-xFac);
                // const xVirtFacMapped = 1024**xVirtFac - 1;
                const xVirtFacMapped = Math.max(0, Math.min((-1/(xVirtFac-1) - 1) * 10, 2**16));
                
                const yFac = facInRange(p[1], fullLeaf.node.box.min[1], fullLeaf.node.box.max[1]);
                const yVirtFac = Math.max(yFac, 1-yFac);
                // const yVirtFacMapped = 1024**yVirtFac - 1;
                const yVirtFacMapped = Math.max(0, Math.min((-1/(yVirtFac-1) - 1) * 10, 2**16));

                return (xSampled * xVirtFacMapped + ySampled * yVirtFacMapped )/(yVirtFacMapped + xVirtFacMapped);





                // const fullLeafSize = [fullLeaf.node.box.max[0] - fullLeaf.node.box.min[0], fullLeaf.node.box.max[1] - fullLeaf.node.box.min[1]];
                // const fullAspect = (fullLeafSize[0])/(fullLeafSize[1]);
                
                // const xVirtFac = Math.max(
                //     1 - (p[0] - fullLeaf.node.box.min[0])/(fullLeafSize[1] * 2), 
                //     1 - (fullLeaf.node.box.max[0] - p[0])/(fullLeafSize[1] * 2)
                // );
                // const xVirtFacMapped = Math.max(0, Math.min(-1/(xVirtFac-1) - 1, 2**16));
                
                // const yFac = facInRange(p[1], fullLeaf.node.box.min[1], fullLeaf.node.box.max[1]) 
                // const yVirtFac = Math.max(
                //     1 - (p[1] - fullLeaf.node.box.min[1])/(fullLeafSize[0] * 2), 
                //     1 - (fullLeaf.node.box.max[1] - p[1])/(fullLeafSize[0] * 2)
                // );
                // const yVirtFacMapped = Math.max(0, Math.min(-1/(yVirtFac-1) - 1, 2**16));


                // // combine the virtual x and y values
                // return Math.max(xVirtFac, yVirtFac);
                // if (xVirtFac > yVirtFac) {
                //     return 0;//xSampled;
                // } else {
                //     return 1;//ySampled;
                // }
                // return (xSampled * xVirtFacMapped + ySampled * yVirtFacMapped )/(yVirtFacMapped + xVirtFacMapped);
            }
            
            const sampleTreeVirtualNew = (tree, p) => {
                var corners = [
                    // each entry is for a different dimension
                    {
                        // each of these is for a face in the direction: min, max point
                        plus: {min:1, max:3},
                        minus: {min:0, max:2},
                    },
                    {
                        plus: {min:2, max:3},
                        minus: {min:0, max:1},
                    }
                ]

                
                var interpolateOnFace = (pos, leafLineSeg, NeighLineSeg) => {

                }
                // get full leaf
                var fullLeaf = getContainingLeafNode(tree, p);

                const neighbourPoints = [
                    [
                        [fullLeaf.node.box.max[0] + epsilon, p[1]],
                        [fullLeaf.node.box.min[0] - epsilon, p[1]]
                    ],
                    [
                        [p[0], fullLeaf.node.box.max[1] + epsilon],
                        [p[0], fullLeaf.node.box.min[1] - epsilon]
                    ]
                ]

                for (let i = 0; i < neighbourPoints.length; i++) {
                    var virtBox = {
                        min: [...fullLeaf.node.box.min],
                        max: [...fullLeaf.node.box.max],
                    };
                    var virtCorn = new Float32Array(8);

                    var plusLeaf = getContainingLeafNode(tree, neighbourPoints[i][0]);
                    var minusLeaf = getContainingLeafNode(tree, neighbourPoints[i][1]);

                    for (let j = 0; j < dimensions; j++) {
                        // j iterates through all orthogonal dimensions
                        if (j == i) continue;

                        // set the min of the box in this orthogonal dimensions
                        
                        var interpNeighbour, interpNeighFace, interpLeafFace;
    
                        // do step 1, setting min bound and pulling in point
                        if (plusLeaf.node.box.min[j] >= fullLeaf.node.box.min[j] && plusLeaf.node.box.min[j] >= minusLeaf.node.box.min[j]) {
                            // plus neighbour is limiting case
                            interpNeighbour = minusLeaf;
                            // set min bound
                            virtBox.min[j] = plusLeaf.node.box.min[j];
                            // set corner
                            virtCorn[corners[i].plus.min] = plusLeaf.cornerVals[corners[i].minus.min];
                            // track needed neighbour face and full leaf face
                            interpNeighFace = corners[i].minus;
                            interpLeafFace = corners[i].plus;
                        } else if (minusLeaf.node.box.min[j] >= plusLeaf.node.box.min[j] && minusLeaf.node.box.min[j] >= fullLeaf.node.box.min[j]) {
                            // minus neighbour is limiting case
                            interpNeighbour = plusLeaf;
                            // set min bound
                            virtBox.min[j] = minusLeaf.node.box.min[j];
                            // set corner
                            virtCorn[corners[i].minus.min] = plusLeaf.cornerVals[corners[i].plus.min];
                            // track faces for interpolation
                            interpNeighFace = corners[i].plus;
                            interpLeafFace = corners[i].minus;
                        } else {
                            // full leaf is limiting case
                            interpNeighbour = null;
                            // set min bound
                            virtBox.min[j] = fullLeaf.node.box.min[j];
                            // set corners
                            virtCorn[corners[i].plus.min] = fullLeaf.cornerVals[corners[i].plus.min];
                            virtCorn[corners[i].minus.min] = fullLeaf.cornerVals[corners[i].minus.min];
                        }
                        
                        // do step 2, interpolate opposite point
                        if (interpNeighbour) {
                            var interpCase = (interpNeighbour.node.box.max[j] < fullLeaf.node.box.max[j]) << 3 | 
                                             (interpNeighbour.node.box.min[j] < fullLeaf.node.box.min[j]) << 2 | 
                                             (interpNeighbour.node.box.max[j] < virtBox.min[j]) << 1 | 
                                             (interpNeighbour.node.box.min[j] < virtBox.min[j]);

                            // 1) k=15
                            // 2) k=11
                            // 3) k=13
                            // 4) k=9
                            // 5) k=1
                            // 6) k=8
                            // 7) k=0
                            // 8) k=5 (default)

                            var fac, minVal, maxVal;
                            
                            
                            switch (interpCase) {
                                case 15: // 1
                                case 11: // 2
                                    minVal = interpNeighbour.cornerVals[interpNeighFace.max];
                                    maxVal = fullLeaf.cornerVals[interpLeafFace.max];
                                    fac = facInRange(virtBox.min[j], interpNeighbour.node.box.max[j], fullLeaf.node.box.max[j]);
                                    break;
                                case 13: // 3
                                    minVal = fullLeaf.cornerVals[interpLeafFace.min];
                                    maxVal = interpNeighbour.cornerVals[interpNeighFace.max];
                                    fac = facInRange(virtBox.min[j], fullLeaf.node.box.min[j], interpNeighbour.node.box.max[j]);
                                    break;
                                case 9: // 4
                                    fac = facInRange(virtBox.min[j], interpNeighbour.node.box.min[j], interpNeighbour.node.box.max[j]);
                                    break;
                                case 1: // 5
                                    fac = facInRange(virtBox.min[j], interpNeighbour.node.box.min[j], fullLeaf.node.box.max[j]);
                                    break;
                                case 8: // 6
                                case 0: // 7
                                    fac = facInRange(virtBox.min[j], fullLeaf.node.box.min[j], interpNeighbour.node.box.min[j]);
                                    break;
                                default:
                                case 5: // 8
                                    fac = facInRange(virtBox.min[j],fullLeaf.node.box.min[j], fullLeaf.node.box.max[j]);
                                    break;
                                
                            }
                        }
                    }
                }
            }
            
            // virtual leaf sampling that works correctly on the subset of trees
            // in which nodes are split in their geometric centre at each level

            // > this algorithm works with the idea of active neighbours which occurs if
            //   a neighbour has a hanging vertex on the edge of the sampled leaf node
            // > Because of the splitting method, if a neighbour is active then it is also
            //   guaranteed to not overhang and be active to neighbouring leaves
            const sampleTreeVirtualNodeMedian = (tree, p) => {
                // get leaf
                var fullLeaf = getContainingLeafNode(tree, p);

                const neighbourPoints = [
                    [fullLeaf.node.box.max[0] + epsilon, p[1]],
                    [p[0], fullLeaf.node.box.max[1] + epsilon],
                    [fullLeaf.node.box.min[0] - epsilon, p[1]],
                    [p[0], fullLeaf.node.box.min[1] - epsilon],
                ];
                const perpDim = [1, 0, 1, 0];

                const posEdge = [true, true, false, false];

                let edgeSamples = [];

                // for each neighbour, check if it is needed
                for (let i = 0; i < 4; i++) {
                    var neighLeaf = getContainingLeafNode(tree, neighbourPoints[i]);
                    if (
                        neighLeaf.node.box.min[perpDim[i]] > fullLeaf.node.box.min[perpDim[i]] || 
                        neighLeaf.node.box.max[perpDim[i]] < fullLeaf.node.box.max[perpDim[i]]
                        // true
                    ) {
                        // this neighbour is active
                        edgeSamples[i] = sampleInBox(neighLeaf.node.box, neighLeaf.cornerVals, neighbourPoints[i]);
                    } else {
                        // can clamp to box in sampling function
                        edgeSamples[i] = sampleInBox(fullLeaf.node.box, fullLeaf.cornerVals, neighbourPoints[i]);
                    }
                }

                // the distances from the central point to the corners
                const lengths = [
                    fullLeaf.node.box.max[0] - p[0] + epsilon,
                    fullLeaf.node.box.max[1] - p[1] + epsilon,
                    p[0] - fullLeaf.node.box.min[0] + epsilon,
                    p[1] - fullLeaf.node.box.min[1] + epsilon,
                ];

                // simpler method
                const weights = [
                    1/lengths[0],
                    1/lengths[1],
                    1/lengths[2],
                    1/lengths[3],
                ];
                // const weights = [
                //     lengths[2]/(lengths[0] + lengths[2]),
                //     lengths[3]/(lengths[1] + lengths[3]),
                //     lengths[0]/(lengths[0] + lengths[2]),
                //     lengths[1]/(lengths[1] + lengths[3]),
                // ];
                
                // interpolate the sampled edge points using wachspress barycentric coordinates

                // // the areas of the triangles formed by centre point, point at i and point at i+1
                // const areas = [
                //     0.5 * lengths[0] * lengths[1],
                //     0.5 * lengths[1] * lengths[2],
                //     0.5 * lengths[2] * lengths[3],
                //     0.5 * lengths[3] * lengths[0],
                // ];
                // // the weights are the area formed by the point and the two adjacent point
                // // over the product of the 
                // const weights = [
                //     (areas[0] + areas[3])/(areas[0]*areas[3]),
                //     (areas[1] + areas[0])/(areas[1]*areas[0]),
                //     (areas[2] + areas[1])/(areas[2]*areas[1]),
                //     (areas[3] + areas[2])/(areas[3]*areas[2]),
                // ];


                const weightSum = weights.reduce((acc, curr) => acc + curr, 0);

                // debugger;

                return edgeSamples.reduce((acc, curr, i) => acc + curr*weights[i]/weightSum, 0);
            }
         
            const getVirtualNodeMedianInfo = (tree, p) => {
                var fullLeaf = getContainingLeafNode(tree, p);
                const points = [
                    [fullLeaf.node.box.max[0] + epsilon, p[1]],
                    [p[0], fullLeaf.node.box.max[1] + epsilon],
                    [fullLeaf.node.box.min[0] - epsilon, p[1]],
                    [p[0], fullLeaf.node.box.min[1] - epsilon],
                ];

                const neighbours = points.map(v => getContainingLeafNode(tree, v));

                const lengths = [
                    fullLeaf.node.box.max[0] - p[0] + epsilon,
                    fullLeaf.node.box.max[1] - p[1] + epsilon,
                    p[0] - fullLeaf.node.box.min[0] + epsilon,
                    p[1] - fullLeaf.node.box.min[1] + epsilon,
                ];
                // the areas of the triangles formed by centre point, point at i and point at i+1
                const areas = [
                    0.5 * lengths[0] * lengths[1],
                    0.5 * lengths[1] * lengths[2],
                    0.5 * lengths[2] * lengths[3],
                    0.5 * lengths[3] * lengths[0],
                ];
                // the weights are the area formed by the point and the two adjacent point
                // over the product of the 
                // const weights = [
                //     (areas[0] + areas[3])/(areas[0]*areas[3]),
                //     (areas[1] + areas[0])/(areas[1]*areas[0]),
                //     (areas[2] + areas[1])/(areas[2]*areas[1]),
                //     (areas[3] + areas[2])/(areas[3]*areas[2]),
                // ];
                const weights = [
                    1/lengths[0],
                    1/lengths[1],
                    1/lengths[2],
                    1/lengths[3],
                ];
                // const weights = [
                //     lengths[2]/(lengths[0] + lengths[2]),
                //     lengths[3]/(lengths[1] + lengths[3]),
                //     lengths[0]/(lengths[0] + lengths[2]),
                //     lengths[1]/(lengths[1] + lengths[3]),
                // ];
                const weightSum = weights.reduce((acc, curr) => acc + curr, 0);

                return {
                    neighbours: neighbours,
                    points: points,
                    baryCoords: weights.map(w => w/weightSum)
                }
            }
            
            const tree = createTree(11, {min: [0, 0], max:[canvas.width, canvas.height]}, scalarFunction);
            drawTree(tree.nodes, "#000000");
            
            
            
            canvas.addEventListener("mousemove", (e) => {
                // console.log("treee");
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawTree(tree.nodes, "#aaaaaa");
                var canvasRect = canvas.getBoundingClientRect();
                var mouseCoords = [e.clientX - canvasRect.left, e.clientY - canvasRect.top];

                var fullLeaf = getContainingLeafNode(tree, mouseCoords);
                drawBox(fullLeaf.node.box, "#ff0000");

                const info = getVirtualNodeMedianInfo(tree, mouseCoords);
                for (let i = 0; i < 4; i++) {
                    const col = "rgb(0, 0, " + Math.round(255*info.baryCoords[i]).toString()+")";
                    // console.log(col);
                    drawBox(info.neighbours[i].node.box, col);
                }
                // console.log(info.baryCoords);
                const samplePoints = info.points;


                ctx.beginPath();
                ctx.strokeStyle = "#0000ff";
                ctx.moveTo(...samplePoints[0]);
                ctx.lineTo(...samplePoints[1]);             
                ctx.lineTo(...samplePoints[2]);             
                ctx.lineTo(...samplePoints[3]);             
                ctx.lineTo(...samplePoints[0]); 
                ctx.stroke();            
                // var virtualLeaf = getVirtualLeafOld(tree, mouseCoords);
                // var xVirtualleafBox = structuredClone(virtualLeaf.node.box);
                // xVirtualleafBox.min[0] = fullLeaf.node.box.min[0];
                // xVirtualleafBox.max[0] = fullLeaf.node.box.max[0];
                // var yVirtualleafBox = structuredClone(virtualLeaf.node.box);
                // yVirtualleafBox.min[1] = fullLeaf.node.box.min[1];
                // yVirtualleafBox.max[1] = fullLeaf.node.box.max[1];

                // drawBox(xVirtualleafBox, "#333333");
                // drawBox(yVirtualleafBox, "#333333");

                // drawBox(virtualLeaf.node.box, "#0000ff");
            })

            document.addEventListener("mousedown", e => {
                var canvasRect = canvas.getBoundingClientRect();
                var mouseCoords = [e.clientX - canvasRect.left, e.clientY - canvasRect.top];
                console.log(sampleTreeVirtualNodeMedian(tree, mouseCoords));
            })

            document.body.addEventListener("keypress", (e) => {
                const start = performance.now();
                switch (e.key) {
                    case "0":
                        drawScalarField(scalarFunction);
                        console.log("drawn data");
                        break;
                    case "1":
                        // draw the scalar field by linearly interpolating the corner values
                        drawTreeCornerVals(tree);
                        console.log("drawn basic tree corners");
                        break;
                    case "2":
                        // draw the scalar field by using the virtual leaf nodes
                        drawTreeCornerVals(tree, "virtual");
                        console.log("drawn corner vals with intersection virtual leaf method");
                        break;
                    case "3":
                        // draw the scalar field by using the virtual leaf nodes
                        drawTreeCornerVals(tree, "median");
                        console.log("drawn corner vals with new method");
                        break;
                    case "4":
                        drawTreeCornerVals(tree, "nearest");
                        console.log("nearest corner vals");
                        break;
                }
                console.log(Math.round(performance.now() - start).toString() + "ms");
            })
        </script>
    </body>
</html>